<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>pycti.api.opencti_api_client API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycti.api.opencti_api_client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding: utf-8

import io
import magic
import requests
import urllib3
import json
import logging

from pycti.api.opencti_api_connector import OpenCTIApiConnector
from pycti.api.opencti_api_job import OpenCTIApiJob
from pycti.utils.constants import ObservableTypes
from pycti.utils.opencti_stix2 import OpenCTIStix2

from pycti.entities.opencti_tag import Tag
from pycti.entities.opencti_marking_definition import MarkingDefinition
from pycti.entities.opencti_external_reference import ExternalReference
from pycti.entities.opencti_kill_chain_phase import KillChainPhase
from pycti.entities.opencti_stix_entity import StixEntity
from pycti.entities.opencti_stix_domain_entity import StixDomainEntity
from pycti.entities.opencti_stix_observable import StixObservable
from pycti.entities.opencti_stix_relation import StixRelation
from pycti.entities.opencti_stix_observable_relation import StixObservableRelation
from pycti.entities.opencti_identity import Identity
from pycti.entities.opencti_threat_actor import ThreatActor
from pycti.entities.opencti_intrusion_set import IntrusionSet
from pycti.entities.opencti_campaign import Campaign
from pycti.entities.opencti_incident import Incident
from pycti.entities.opencti_malware import Malware
from pycti.entities.opencti_tool import Tool
from pycti.entities.opencti_vulnerability import Vulnerability
from pycti.entities.opencti_attack_pattern import AttackPattern
from pycti.entities.opencti_course_of_action import CourseOfAction
from pycti.entities.opencti_report import Report
from pycti.entities.opencti_note import Note
from pycti.entities.opencti_opinion import Opinion
from pycti.entities.opencti_indicator import Indicator

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class File:
    def __init__(self, name, data, mime=&#34;text/plain&#34;):
        self.name = name
        self.data = data
        self.mime = mime


class OpenCTIApiClient:
    &#34;&#34;&#34;
        Python API for OpenCTI
        :param url: OpenCTI URL
        :param token: The API key
    &#34;&#34;&#34;

    def __init__(self, url, token, log_level=&#34;info&#34;, ssl_verify=False):
        # Check configuration
        self.ssl_verify = ssl_verify
        if url is None or len(token) == 0:
            raise ValueError(&#34;Url configuration must be configured&#34;)
        if token is None or len(token) == 0 or token == &#34;ChangeMe&#34;:
            raise ValueError(
                &#34;Token configuration must be the same as APP__ADMIN__TOKEN&#34;
            )

        # Configure logger
        self.log_level = log_level
        numeric_level = getattr(logging, self.log_level.upper(), None)
        if not isinstance(numeric_level, int):
            raise ValueError(&#34;Invalid log level: &#34; + self.log_level)
        logging.basicConfig(level=numeric_level)

        # Define API
        self.api_url = url + &#34;/graphql&#34;
        self.request_headers = {&#34;Authorization&#34;: &#34;Bearer &#34; + token}

        # Define the dependencies
        self.job = OpenCTIApiJob(self)
        self.connector = OpenCTIApiConnector(self)
        self.stix2 = OpenCTIStix2(self)

        # Define the entities
        self.tag = Tag(self)
        self.marking_definition = MarkingDefinition(self)
        self.external_reference = ExternalReference(self)
        self.kill_chain_phase = KillChainPhase(self)
        self.stix_entity = StixEntity(self)
        self.stix_domain_entity = StixDomainEntity(self, File)
        self.stix_observable = StixObservable(self)
        self.stix_relation = StixRelation(self)
        self.stix_observable_relation = StixObservableRelation(self)
        self.identity = Identity(self)
        self.threat_actor = ThreatActor(self)
        self.intrusion_set = IntrusionSet(self)
        self.campaign = Campaign(self)
        self.incident = Incident(self)
        self.malware = Malware(self)
        self.tool = Tool(self)
        self.vulnerability = Vulnerability(self)
        self.attack_pattern = AttackPattern(self)
        self.course_of_action = CourseOfAction(self)
        self.report = Report(self)
        self.note = Note(self)
        self.opinion = Opinion(self)
        self.indicator = Indicator(self)

        # Check if openCTI is available
        if not self.health_check():
            raise ValueError(
                &#34;OpenCTI API is not reachable. Waiting for OpenCTI API to start or check your configuration...&#34;
            )

    def query(self, query, variables={}):
        query_var = {}
        files_vars = []
        # Implementation of spec https://github.com/jaydenseric/graphql-multipart-request-spec
        # Support for single or multiple upload
        # Batching or mixed upload or not supported
        var_keys = variables.keys()
        for key in var_keys:
            val = variables[key]
            is_file = type(val) is File
            is_files = (
                isinstance(val, list)
                and len(val) &gt; 0
                and all(map(lambda x: isinstance(x, File), val))
            )
            if is_file or is_files:
                files_vars.append({&#34;key&#34;: key, &#34;file&#34;: val, &#34;multiple&#34;: is_files})
                query_var[key] = None if is_file else [None] * len(val)
            else:
                query_var[key] = val

        # If yes, transform variable (file to null) and create multipart query
        if len(files_vars) &gt; 0:
            multipart_data = {
                &#34;operations&#34;: json.dumps({&#34;query&#34;: query, &#34;variables&#34;: query_var})
            }
            # Build the multipart map
            map_index = 0
            file_vars = {}
            for file_var_item in files_vars:
                is_multiple_files = file_var_item[&#34;multiple&#34;]
                var_name = &#34;variables.&#34; + file_var_item[&#34;key&#34;]
                if is_multiple_files:
                    # [(var_name + &#34;.&#34; + i)] if is_multiple_files else
                    for _ in file_var_item[&#34;file&#34;]:
                        file_vars[str(map_index)] = [(var_name + &#34;.&#34; + str(map_index))]
                        map_index += 1
                else:
                    file_vars[str(map_index)] = [var_name]
                    map_index += 1
            multipart_data[&#34;map&#34;] = json.dumps(file_vars)
            # Add the files
            file_index = 0
            multipart_files = []
            for file_var_item in files_vars:
                files = file_var_item[&#34;file&#34;]
                is_multiple_files = file_var_item[&#34;multiple&#34;]
                if is_multiple_files:
                    for file in files:
                        if isinstance(file.data, str):
                            file_multi = (
                                str(file_index),
                                (file.name, io.BytesIO(file.data.encode()), file.mime,),
                            )
                        else:
                            file_multi = (
                                str(file_index),
                                (file.name, file.data, file.mime),
                            )
                        multipart_files.append(file_multi)
                        file_index += 1
                else:
                    if isinstance(files.data, str):
                        file_multi = (
                            str(file_index),
                            (files.name, io.BytesIO(files.data.encode()), files.mime),
                        )
                    else:
                        file_multi = (
                            str(file_index),
                            (files.name, files.data, files.mime),
                        )
                    multipart_files.append(file_multi)
                    file_index += 1
            # Send the multipart request
            r = requests.post(
                self.api_url,
                data=multipart_data,
                files=multipart_files,
                headers=self.request_headers,
                verify=self.ssl_verify,
            )
        # If no
        else:
            r = requests.post(
                self.api_url,
                json={&#34;query&#34;: query, &#34;variables&#34;: variables},
                headers=self.request_headers,
                verify=self.ssl_verify,
            )
        # Build response
        if r.status_code == requests.codes.ok:
            result = r.json()
            if &#34;errors&#34; in result:
                logging.error(result[&#34;errors&#34;][0][&#34;message&#34;])
            else:
                return result
        else:
            logging.info(r.text)

    def fetch_opencti_file(self, fetch_uri, binary=False):
        r = requests.get(fetch_uri, headers=self.request_headers)
        if binary:
            return r.content
        return r.text

    def log(self, level, message):
        if level == &#34;debug&#34;:
            logging.debug(message)
        elif level == &#34;info&#34;:
            logging.info(message)
        elif level == &#34;warning&#34;:
            logging.warn(message)
        elif level == &#34;error&#34;:
            logging.error(message)

    def health_check(self):
        try:
            test = self.threat_actor.list(first=1)
            if test is not None:
                return True
        except:
            return False
        return False

    def not_empty(self, value):
        if value is not None:
            if isinstance(value, str):
                if len(value) &gt; 0:
                    return True
                else:
                    return False
            if isinstance(value, list):
                is_not_empty = False
                for v in value:
                    if len(v) &gt; 0:
                        is_not_empty = True
                return is_not_empty
            if isinstance(value, int):
                return True
            else:
                return False
        else:
            return False

    def process_multiple(self, data):
        result = []
        if data is None:
            return result
        for edge in (
            data[&#34;edges&#34;] if &#34;edges&#34; in data and data[&#34;edges&#34;] is not None else []
        ):
            row = edge[&#34;node&#34;]
            # Handle remote relation ID
            if (
                &#34;relation&#34; in edge
                and edge[&#34;relation&#34;] is not None
                and &#34;id&#34; in edge[&#34;relation&#34;]
            ):
                row[&#34;remote_relation_id&#34;] = edge[&#34;relation&#34;][&#34;id&#34;]
            result.append(self.process_multiple_fields(row))
        return result

    def process_multiple_ids(self, data):
        result = []
        if data is None:
            return result
        if isinstance(data, list):
            for d in data:
                if isinstance(d, dict) and &#34;id&#34; in d:
                    result.append(d[&#34;id&#34;])
        return result

    def process_multiple_fields(self, data):
        if data is None:
            return data
        if (
            &#34;createdByRef&#34; in data
            and data[&#34;createdByRef&#34;] is not None
            and &#34;node&#34; in data[&#34;createdByRef&#34;]
        ):
            row = data[&#34;createdByRef&#34;][&#34;node&#34;]
            # Handle remote relation ID
            if &#34;relation&#34; in data[&#34;createdByRef&#34;]:
                row[&#34;remote_relation_id&#34;] = data[&#34;createdByRef&#34;][&#34;relation&#34;][&#34;id&#34;]
            data[&#34;createdByRef&#34;] = row
        else:
            data[&#34;createdByRef&#34;] = None
        if &#34;markingDefinitions&#34; in data:
            data[&#34;markingDefinitions&#34;] = self.process_multiple(
                data[&#34;markingDefinitions&#34;]
            )
            data[&#34;markingDefinitionsIds&#34;] = self.process_multiple_ids(
                data[&#34;markingDefinitions&#34;]
            )
        if &#34;tags&#34; in data:
            data[&#34;tags&#34;] = self.process_multiple(data[&#34;tags&#34;])
            data[&#34;tagsIds&#34;] = self.process_multiple_ids(data[&#34;tags&#34;])
        if &#34;reports&#34; in data:
            data[&#34;reports&#34;] = self.process_multiple(data[&#34;reports&#34;])
            data[&#34;reportsIds&#34;] = self.process_multiple_ids(data[&#34;reports&#34;])
        if &#34;killChainPhases&#34; in data:
            data[&#34;killChainPhases&#34;] = self.process_multiple(data[&#34;killChainPhases&#34;])
            data[&#34;killChainPhasesIds&#34;] = self.process_multiple_ids(
                data[&#34;killChainPhases&#34;]
            )
        if &#34;externalReferences&#34; in data:
            data[&#34;externalReferences&#34;] = self.process_multiple(
                data[&#34;externalReferences&#34;]
            )
            data[&#34;externalReferencesIds&#34;] = self.process_multiple_ids(
                data[&#34;externalReferences&#34;]
            )
        if &#34;objectRefs&#34; in data:
            data[&#34;objectRefs&#34;] = self.process_multiple(data[&#34;objectRefs&#34;])
            data[&#34;objectRefsIds&#34;] = self.process_multiple_ids(data[&#34;objectRefs&#34;])
        if &#34;observableRefs&#34; in data:
            data[&#34;observableRefs&#34;] = self.process_multiple(data[&#34;observableRefs&#34;])
            data[&#34;observableRefsIds&#34;] = self.process_multiple_ids(
                data[&#34;observableRefs&#34;]
            )
        if &#34;relationRefs&#34; in data:
            data[&#34;relationRefs&#34;] = self.process_multiple(data[&#34;relationRefs&#34;])
            data[&#34;relationRefsIds&#34;] = self.process_multiple_ids(data[&#34;relationRefs&#34;])
        if &#34;stixRelations&#34; in data:
            data[&#34;stixRelations&#34;] = self.process_multiple(data[&#34;stixRelations&#34;])
            data[&#34;stixRelationsIds&#34;] = self.process_multiple_ids(data[&#34;stixRelations&#34;])
        if &#34;indicators&#34; in data:
            data[&#34;indicators&#34;] = self.process_multiple(data[&#34;indicators&#34;])
            data[&#34;indicatorsIds&#34;] = self.process_multiple_ids(data[&#34;indicators&#34;])
        if &#34;importFiles&#34; in data:
            data[&#34;importFiles&#34;] = self.process_multiple(data[&#34;importFiles&#34;])
            data[&#34;importFilesIds&#34;] = self.process_multiple_ids(data[&#34;importFiles&#34;])
        return data

    def upload_file(self, **kwargs):
        file_name = kwargs.get(&#34;file_name&#34;, None)
        data = kwargs.get(&#34;data&#34;, None)
        mime_type = kwargs.get(&#34;mime_type&#34;, &#34;text/plain&#34;)
        if file_name is not None:
            self.log(&#34;info&#34;, &#34;Uploading a file.&#34;)
            query = &#34;&#34;&#34;
                mutation UploadImport($file: Upload!) {
                    uploadImport(file: $file) {
                        id
                        name
                    }
                }
             &#34;&#34;&#34;
            if data is None:
                data = open(file_name, &#34;rb&#34;)
                mime_type = magic.from_file(file_name, mime=True)

            return self.query(query, {&#34;file&#34;: (File(file_name, data, mime_type))})
        else:
            self.log(
                &#34;error&#34;, &#34;[upload] Missing parameters: file_name or data&#34;,
            )
            return None

    # TODO Move to StixObservable
    def update_stix_observable_field(self, id, key, value):
        logging.info(&#34;Updating field &#34; + key + &#34; of &#34; + id + &#34;...&#34;)
        query = &#34;&#34;&#34;
            mutation StixObservableEdit($id: ID!, $input: EditInput!) {
                stixObservableEdit(id: $id) {
                    fieldPatch(input: $input) {
                        id
                        observable_value
                        entity_type
                    }
                }
            }
        &#34;&#34;&#34;
        self.query(query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}})

    # TODO Move to ExternalReference
    def delete_external_reference(self, id):
        logging.info(&#34;Deleting + &#34; + id + &#34;...&#34;)
        query = &#34;&#34;&#34;
             mutation ExternalReferenceEdit($id: ID!) {
                 externalReferenceEdit(id: $id) {
                     delete
                 }
             }
         &#34;&#34;&#34;
        self.query(query, {&#34;id&#34;: id})

    # TODO Move to Vulnerability
    def create_vulnerability_if_not_exists(
        self,
        name,
        description,
        alias=None,
        id=None,
        stix_id_key=None,
        created=None,
        modified=None,
        update=False,
    ):
        return self.vulnerability.create(
            name=name,
            description=description,
            alias=alias,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            update=update,
        )

    def resolve_role(self, relation_type, from_type, to_type):
        if from_type == &#34;stix-relation&#34;:
            from_type = &#34;stix_relation&#34;
        if to_type == &#34;stix-relation&#34;:
            to_type = &#34;stix_relation&#34;
        if relation_type == &#34;related-to&#34;:
            return {&#34;from_role&#34;: &#34;relate_from&#34;, &#34;to_role&#34;: &#34;relate_to&#34;}

        relation_type = relation_type.lower()
        from_type = from_type.lower()
        from_type = (
            &#34;observable&#34;
            if (
                (
                    ObservableTypes.has_value(from_type)
                    and (
                        relation_type == &#34;localization&#34; or relation_type == &#34;gathering&#34;
                    )
                )
                or from_type == &#34;stix-observable&#34;
            )
            else from_type
        )
        to_type = to_type.lower()
        mapping = {
            &#34;uses&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;intrusion-set&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;campaign&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;incident&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;malware&#34;: {
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;tool&#34;: {&#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;}},
            },
            &#34;variant-of&#34;: {
                &#34;malware&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;original&#34;, &#34;to_role&#34;: &#34;variation&#34;},
                },
                &#34;tool&#34;: {&#34;tool&#34;: {&#34;from_role&#34;: &#34;original&#34;, &#34;to_role&#34;: &#34;variation&#34;},},
            },
            &#34;targets&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;intrusion-set&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;campaign&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;incident&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;malware&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;attack-pattern&#34;: {
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
            },
            &#34;attributed-to&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;intrusion-set&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;campaign&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;intrusion-set&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;incident&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;intrusion-set&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;campaign&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;malware&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
            },
            &#34;mitigates&#34;: {
                &#34;course-of-action&#34;: {
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;mitigation&#34;, &#34;to_role&#34;: &#34;problem&#34;}
                }
            },
            &#34;localization&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
                &#34;observable&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
                &#34;stix_relation&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
                &#34;region&#34;: {&#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}},
                &#34;country&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}
                },
                &#34;city&#34;: {&#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}},
                &#34;organization&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
            },
            &#34;indicates&#34;: {
                &#34;indicator&#34;: {
                    &#34;threat-actor&#34;: {
                        &#34;from_role&#34;: &#34;indicator&#34;,
                        &#34;to_role&#34;: &#34;characterize&#34;,
                    },
                    &#34;intrusion-set&#34;: {
                        &#34;from_role&#34;: &#34;indicator&#34;,
                        &#34;to_role&#34;: &#34;characterize&#34;,
                    },
                    &#34;campaign&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                    &#34;stix_relation&#34;: {
                        &#34;from_role&#34;: &#34;indicator&#34;,
                        &#34;to_role&#34;: &#34;characterize&#34;,
                    },
                }
            },
            &#34;gathering&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;sector&#34;: {
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;organization&#34;: {
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;user&#34;: {
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;observable&#34;: {
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
            },
            &#34;drops&#34;: {
                &#34;malware&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                },
                &#34;tool&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                },
            },
            &#34;belongs&#34;: {
                &#34;ipv4-addr&#34;: {
                    &#34;autonomous-system&#34;: {
                        &#34;from_role&#34;: &#34;belonging_to&#34;,
                        &#34;to_role&#34;: &#34;belonged_to&#34;,
                    }
                },
                &#34;ipv6-addr&#34;: {
                    &#34;autonomous-system&#34;: {
                        &#34;from_role&#34;: &#34;belonging_to&#34;,
                        &#34;to_role&#34;: &#34;belonged_to&#34;,
                    }
                },
            },
            &#34;resolves&#34;: {
                &#34;ipv4-addr&#34;: {
                    &#34;domain&#34;: {&#34;from_role&#34;: &#34;resolving&#34;, &#34;to_role&#34;: &#34;resolved&#34;,}
                },
                &#34;ipv6-addr&#34;: {
                    &#34;domain&#34;: {&#34;from_role&#34;: &#34;resolving&#34;, &#34;to_role&#34;: &#34;resolved&#34;,}
                },
            },
            &#34;corresponds&#34;: {
                &#34;file-name&#34;: {
                    &#34;file-md5&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha1&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha256&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
                &#34;file-md5&#34;: {
                    &#34;file-name&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha1&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha256&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
                &#34;file-sha1&#34;: {
                    &#34;file-name&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-md5&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha256&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
                &#34;file-sha256&#34;: {
                    &#34;file-name&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-md5&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha1&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
            },
        }
        if (
            relation_type in mapping
            and from_type in mapping[relation_type]
            and to_type in mapping[relation_type][from_type]
        ):
            return mapping[relation_type][from_type][to_type]
        else:
            return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycti.api.opencti_api_client.File"><code class="flex name class">
<span>class <span class="ident">File</span></span>
<span>(</span><span>name, data, mime='text/plain')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class File:
    def __init__(self, name, data, mime=&#34;text/plain&#34;):
        self.name = name
        self.data = data
        self.mime = mime</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient"><code class="flex name class">
<span>class <span class="ident">OpenCTIApiClient</span></span>
<span>(</span><span>url, token, log_level='info', ssl_verify=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Python API for OpenCTI
:param url: OpenCTI URL
:param token: The API key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenCTIApiClient:
    &#34;&#34;&#34;
        Python API for OpenCTI
        :param url: OpenCTI URL
        :param token: The API key
    &#34;&#34;&#34;

    def __init__(self, url, token, log_level=&#34;info&#34;, ssl_verify=False):
        # Check configuration
        self.ssl_verify = ssl_verify
        if url is None or len(token) == 0:
            raise ValueError(&#34;Url configuration must be configured&#34;)
        if token is None or len(token) == 0 or token == &#34;ChangeMe&#34;:
            raise ValueError(
                &#34;Token configuration must be the same as APP__ADMIN__TOKEN&#34;
            )

        # Configure logger
        self.log_level = log_level
        numeric_level = getattr(logging, self.log_level.upper(), None)
        if not isinstance(numeric_level, int):
            raise ValueError(&#34;Invalid log level: &#34; + self.log_level)
        logging.basicConfig(level=numeric_level)

        # Define API
        self.api_url = url + &#34;/graphql&#34;
        self.request_headers = {&#34;Authorization&#34;: &#34;Bearer &#34; + token}

        # Define the dependencies
        self.job = OpenCTIApiJob(self)
        self.connector = OpenCTIApiConnector(self)
        self.stix2 = OpenCTIStix2(self)

        # Define the entities
        self.tag = Tag(self)
        self.marking_definition = MarkingDefinition(self)
        self.external_reference = ExternalReference(self)
        self.kill_chain_phase = KillChainPhase(self)
        self.stix_entity = StixEntity(self)
        self.stix_domain_entity = StixDomainEntity(self, File)
        self.stix_observable = StixObservable(self)
        self.stix_relation = StixRelation(self)
        self.stix_observable_relation = StixObservableRelation(self)
        self.identity = Identity(self)
        self.threat_actor = ThreatActor(self)
        self.intrusion_set = IntrusionSet(self)
        self.campaign = Campaign(self)
        self.incident = Incident(self)
        self.malware = Malware(self)
        self.tool = Tool(self)
        self.vulnerability = Vulnerability(self)
        self.attack_pattern = AttackPattern(self)
        self.course_of_action = CourseOfAction(self)
        self.report = Report(self)
        self.note = Note(self)
        self.opinion = Opinion(self)
        self.indicator = Indicator(self)

        # Check if openCTI is available
        if not self.health_check():
            raise ValueError(
                &#34;OpenCTI API is not reachable. Waiting for OpenCTI API to start or check your configuration...&#34;
            )

    def query(self, query, variables={}):
        query_var = {}
        files_vars = []
        # Implementation of spec https://github.com/jaydenseric/graphql-multipart-request-spec
        # Support for single or multiple upload
        # Batching or mixed upload or not supported
        var_keys = variables.keys()
        for key in var_keys:
            val = variables[key]
            is_file = type(val) is File
            is_files = (
                isinstance(val, list)
                and len(val) &gt; 0
                and all(map(lambda x: isinstance(x, File), val))
            )
            if is_file or is_files:
                files_vars.append({&#34;key&#34;: key, &#34;file&#34;: val, &#34;multiple&#34;: is_files})
                query_var[key] = None if is_file else [None] * len(val)
            else:
                query_var[key] = val

        # If yes, transform variable (file to null) and create multipart query
        if len(files_vars) &gt; 0:
            multipart_data = {
                &#34;operations&#34;: json.dumps({&#34;query&#34;: query, &#34;variables&#34;: query_var})
            }
            # Build the multipart map
            map_index = 0
            file_vars = {}
            for file_var_item in files_vars:
                is_multiple_files = file_var_item[&#34;multiple&#34;]
                var_name = &#34;variables.&#34; + file_var_item[&#34;key&#34;]
                if is_multiple_files:
                    # [(var_name + &#34;.&#34; + i)] if is_multiple_files else
                    for _ in file_var_item[&#34;file&#34;]:
                        file_vars[str(map_index)] = [(var_name + &#34;.&#34; + str(map_index))]
                        map_index += 1
                else:
                    file_vars[str(map_index)] = [var_name]
                    map_index += 1
            multipart_data[&#34;map&#34;] = json.dumps(file_vars)
            # Add the files
            file_index = 0
            multipart_files = []
            for file_var_item in files_vars:
                files = file_var_item[&#34;file&#34;]
                is_multiple_files = file_var_item[&#34;multiple&#34;]
                if is_multiple_files:
                    for file in files:
                        if isinstance(file.data, str):
                            file_multi = (
                                str(file_index),
                                (file.name, io.BytesIO(file.data.encode()), file.mime,),
                            )
                        else:
                            file_multi = (
                                str(file_index),
                                (file.name, file.data, file.mime),
                            )
                        multipart_files.append(file_multi)
                        file_index += 1
                else:
                    if isinstance(files.data, str):
                        file_multi = (
                            str(file_index),
                            (files.name, io.BytesIO(files.data.encode()), files.mime),
                        )
                    else:
                        file_multi = (
                            str(file_index),
                            (files.name, files.data, files.mime),
                        )
                    multipart_files.append(file_multi)
                    file_index += 1
            # Send the multipart request
            r = requests.post(
                self.api_url,
                data=multipart_data,
                files=multipart_files,
                headers=self.request_headers,
                verify=self.ssl_verify,
            )
        # If no
        else:
            r = requests.post(
                self.api_url,
                json={&#34;query&#34;: query, &#34;variables&#34;: variables},
                headers=self.request_headers,
                verify=self.ssl_verify,
            )
        # Build response
        if r.status_code == requests.codes.ok:
            result = r.json()
            if &#34;errors&#34; in result:
                logging.error(result[&#34;errors&#34;][0][&#34;message&#34;])
            else:
                return result
        else:
            logging.info(r.text)

    def fetch_opencti_file(self, fetch_uri, binary=False):
        r = requests.get(fetch_uri, headers=self.request_headers)
        if binary:
            return r.content
        return r.text

    def log(self, level, message):
        if level == &#34;debug&#34;:
            logging.debug(message)
        elif level == &#34;info&#34;:
            logging.info(message)
        elif level == &#34;warning&#34;:
            logging.warn(message)
        elif level == &#34;error&#34;:
            logging.error(message)

    def health_check(self):
        try:
            test = self.threat_actor.list(first=1)
            if test is not None:
                return True
        except:
            return False
        return False

    def not_empty(self, value):
        if value is not None:
            if isinstance(value, str):
                if len(value) &gt; 0:
                    return True
                else:
                    return False
            if isinstance(value, list):
                is_not_empty = False
                for v in value:
                    if len(v) &gt; 0:
                        is_not_empty = True
                return is_not_empty
            if isinstance(value, int):
                return True
            else:
                return False
        else:
            return False

    def process_multiple(self, data):
        result = []
        if data is None:
            return result
        for edge in (
            data[&#34;edges&#34;] if &#34;edges&#34; in data and data[&#34;edges&#34;] is not None else []
        ):
            row = edge[&#34;node&#34;]
            # Handle remote relation ID
            if (
                &#34;relation&#34; in edge
                and edge[&#34;relation&#34;] is not None
                and &#34;id&#34; in edge[&#34;relation&#34;]
            ):
                row[&#34;remote_relation_id&#34;] = edge[&#34;relation&#34;][&#34;id&#34;]
            result.append(self.process_multiple_fields(row))
        return result

    def process_multiple_ids(self, data):
        result = []
        if data is None:
            return result
        if isinstance(data, list):
            for d in data:
                if isinstance(d, dict) and &#34;id&#34; in d:
                    result.append(d[&#34;id&#34;])
        return result

    def process_multiple_fields(self, data):
        if data is None:
            return data
        if (
            &#34;createdByRef&#34; in data
            and data[&#34;createdByRef&#34;] is not None
            and &#34;node&#34; in data[&#34;createdByRef&#34;]
        ):
            row = data[&#34;createdByRef&#34;][&#34;node&#34;]
            # Handle remote relation ID
            if &#34;relation&#34; in data[&#34;createdByRef&#34;]:
                row[&#34;remote_relation_id&#34;] = data[&#34;createdByRef&#34;][&#34;relation&#34;][&#34;id&#34;]
            data[&#34;createdByRef&#34;] = row
        else:
            data[&#34;createdByRef&#34;] = None
        if &#34;markingDefinitions&#34; in data:
            data[&#34;markingDefinitions&#34;] = self.process_multiple(
                data[&#34;markingDefinitions&#34;]
            )
            data[&#34;markingDefinitionsIds&#34;] = self.process_multiple_ids(
                data[&#34;markingDefinitions&#34;]
            )
        if &#34;tags&#34; in data:
            data[&#34;tags&#34;] = self.process_multiple(data[&#34;tags&#34;])
            data[&#34;tagsIds&#34;] = self.process_multiple_ids(data[&#34;tags&#34;])
        if &#34;reports&#34; in data:
            data[&#34;reports&#34;] = self.process_multiple(data[&#34;reports&#34;])
            data[&#34;reportsIds&#34;] = self.process_multiple_ids(data[&#34;reports&#34;])
        if &#34;killChainPhases&#34; in data:
            data[&#34;killChainPhases&#34;] = self.process_multiple(data[&#34;killChainPhases&#34;])
            data[&#34;killChainPhasesIds&#34;] = self.process_multiple_ids(
                data[&#34;killChainPhases&#34;]
            )
        if &#34;externalReferences&#34; in data:
            data[&#34;externalReferences&#34;] = self.process_multiple(
                data[&#34;externalReferences&#34;]
            )
            data[&#34;externalReferencesIds&#34;] = self.process_multiple_ids(
                data[&#34;externalReferences&#34;]
            )
        if &#34;objectRefs&#34; in data:
            data[&#34;objectRefs&#34;] = self.process_multiple(data[&#34;objectRefs&#34;])
            data[&#34;objectRefsIds&#34;] = self.process_multiple_ids(data[&#34;objectRefs&#34;])
        if &#34;observableRefs&#34; in data:
            data[&#34;observableRefs&#34;] = self.process_multiple(data[&#34;observableRefs&#34;])
            data[&#34;observableRefsIds&#34;] = self.process_multiple_ids(
                data[&#34;observableRefs&#34;]
            )
        if &#34;relationRefs&#34; in data:
            data[&#34;relationRefs&#34;] = self.process_multiple(data[&#34;relationRefs&#34;])
            data[&#34;relationRefsIds&#34;] = self.process_multiple_ids(data[&#34;relationRefs&#34;])
        if &#34;stixRelations&#34; in data:
            data[&#34;stixRelations&#34;] = self.process_multiple(data[&#34;stixRelations&#34;])
            data[&#34;stixRelationsIds&#34;] = self.process_multiple_ids(data[&#34;stixRelations&#34;])
        if &#34;indicators&#34; in data:
            data[&#34;indicators&#34;] = self.process_multiple(data[&#34;indicators&#34;])
            data[&#34;indicatorsIds&#34;] = self.process_multiple_ids(data[&#34;indicators&#34;])
        if &#34;importFiles&#34; in data:
            data[&#34;importFiles&#34;] = self.process_multiple(data[&#34;importFiles&#34;])
            data[&#34;importFilesIds&#34;] = self.process_multiple_ids(data[&#34;importFiles&#34;])
        return data

    def upload_file(self, **kwargs):
        file_name = kwargs.get(&#34;file_name&#34;, None)
        data = kwargs.get(&#34;data&#34;, None)
        mime_type = kwargs.get(&#34;mime_type&#34;, &#34;text/plain&#34;)
        if file_name is not None:
            self.log(&#34;info&#34;, &#34;Uploading a file.&#34;)
            query = &#34;&#34;&#34;
                mutation UploadImport($file: Upload!) {
                    uploadImport(file: $file) {
                        id
                        name
                    }
                }
             &#34;&#34;&#34;
            if data is None:
                data = open(file_name, &#34;rb&#34;)
                mime_type = magic.from_file(file_name, mime=True)

            return self.query(query, {&#34;file&#34;: (File(file_name, data, mime_type))})
        else:
            self.log(
                &#34;error&#34;, &#34;[upload] Missing parameters: file_name or data&#34;,
            )
            return None

    # TODO Move to StixObservable
    def update_stix_observable_field(self, id, key, value):
        logging.info(&#34;Updating field &#34; + key + &#34; of &#34; + id + &#34;...&#34;)
        query = &#34;&#34;&#34;
            mutation StixObservableEdit($id: ID!, $input: EditInput!) {
                stixObservableEdit(id: $id) {
                    fieldPatch(input: $input) {
                        id
                        observable_value
                        entity_type
                    }
                }
            }
        &#34;&#34;&#34;
        self.query(query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}})

    # TODO Move to ExternalReference
    def delete_external_reference(self, id):
        logging.info(&#34;Deleting + &#34; + id + &#34;...&#34;)
        query = &#34;&#34;&#34;
             mutation ExternalReferenceEdit($id: ID!) {
                 externalReferenceEdit(id: $id) {
                     delete
                 }
             }
         &#34;&#34;&#34;
        self.query(query, {&#34;id&#34;: id})

    # TODO Move to Vulnerability
    def create_vulnerability_if_not_exists(
        self,
        name,
        description,
        alias=None,
        id=None,
        stix_id_key=None,
        created=None,
        modified=None,
        update=False,
    ):
        return self.vulnerability.create(
            name=name,
            description=description,
            alias=alias,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            update=update,
        )

    def resolve_role(self, relation_type, from_type, to_type):
        if from_type == &#34;stix-relation&#34;:
            from_type = &#34;stix_relation&#34;
        if to_type == &#34;stix-relation&#34;:
            to_type = &#34;stix_relation&#34;
        if relation_type == &#34;related-to&#34;:
            return {&#34;from_role&#34;: &#34;relate_from&#34;, &#34;to_role&#34;: &#34;relate_to&#34;}

        relation_type = relation_type.lower()
        from_type = from_type.lower()
        from_type = (
            &#34;observable&#34;
            if (
                (
                    ObservableTypes.has_value(from_type)
                    and (
                        relation_type == &#34;localization&#34; or relation_type == &#34;gathering&#34;
                    )
                )
                or from_type == &#34;stix-observable&#34;
            )
            else from_type
        )
        to_type = to_type.lower()
        mapping = {
            &#34;uses&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;intrusion-set&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;campaign&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;incident&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;malware&#34;: {
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;tool&#34;: {&#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;}},
            },
            &#34;variant-of&#34;: {
                &#34;malware&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;original&#34;, &#34;to_role&#34;: &#34;variation&#34;},
                },
                &#34;tool&#34;: {&#34;tool&#34;: {&#34;from_role&#34;: &#34;original&#34;, &#34;to_role&#34;: &#34;variation&#34;},},
            },
            &#34;targets&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;intrusion-set&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;campaign&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;incident&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;malware&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;attack-pattern&#34;: {
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
            },
            &#34;attributed-to&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;intrusion-set&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;campaign&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;intrusion-set&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;incident&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;intrusion-set&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;campaign&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;malware&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
            },
            &#34;mitigates&#34;: {
                &#34;course-of-action&#34;: {
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;mitigation&#34;, &#34;to_role&#34;: &#34;problem&#34;}
                }
            },
            &#34;localization&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
                &#34;observable&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
                &#34;stix_relation&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
                &#34;region&#34;: {&#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}},
                &#34;country&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}
                },
                &#34;city&#34;: {&#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}},
                &#34;organization&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
            },
            &#34;indicates&#34;: {
                &#34;indicator&#34;: {
                    &#34;threat-actor&#34;: {
                        &#34;from_role&#34;: &#34;indicator&#34;,
                        &#34;to_role&#34;: &#34;characterize&#34;,
                    },
                    &#34;intrusion-set&#34;: {
                        &#34;from_role&#34;: &#34;indicator&#34;,
                        &#34;to_role&#34;: &#34;characterize&#34;,
                    },
                    &#34;campaign&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                    &#34;stix_relation&#34;: {
                        &#34;from_role&#34;: &#34;indicator&#34;,
                        &#34;to_role&#34;: &#34;characterize&#34;,
                    },
                }
            },
            &#34;gathering&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;sector&#34;: {
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;organization&#34;: {
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;user&#34;: {
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;observable&#34;: {
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
            },
            &#34;drops&#34;: {
                &#34;malware&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                },
                &#34;tool&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                },
            },
            &#34;belongs&#34;: {
                &#34;ipv4-addr&#34;: {
                    &#34;autonomous-system&#34;: {
                        &#34;from_role&#34;: &#34;belonging_to&#34;,
                        &#34;to_role&#34;: &#34;belonged_to&#34;,
                    }
                },
                &#34;ipv6-addr&#34;: {
                    &#34;autonomous-system&#34;: {
                        &#34;from_role&#34;: &#34;belonging_to&#34;,
                        &#34;to_role&#34;: &#34;belonged_to&#34;,
                    }
                },
            },
            &#34;resolves&#34;: {
                &#34;ipv4-addr&#34;: {
                    &#34;domain&#34;: {&#34;from_role&#34;: &#34;resolving&#34;, &#34;to_role&#34;: &#34;resolved&#34;,}
                },
                &#34;ipv6-addr&#34;: {
                    &#34;domain&#34;: {&#34;from_role&#34;: &#34;resolving&#34;, &#34;to_role&#34;: &#34;resolved&#34;,}
                },
            },
            &#34;corresponds&#34;: {
                &#34;file-name&#34;: {
                    &#34;file-md5&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha1&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha256&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
                &#34;file-md5&#34;: {
                    &#34;file-name&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha1&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha256&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
                &#34;file-sha1&#34;: {
                    &#34;file-name&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-md5&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha256&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
                &#34;file-sha256&#34;: {
                    &#34;file-name&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-md5&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha1&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
            },
        }
        if (
            relation_type in mapping
            and from_type in mapping[relation_type]
            and to_type in mapping[relation_type][from_type]
        ):
            return mapping[relation_type][from_type][to_type]
        else:
            return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.create_vulnerability_if_not_exists"><code class="name flex">
<span>def <span class="ident">create_vulnerability_if_not_exists</span></span>(<span>self, name, description, alias=None, id=None, stix_id_key=None, created=None, modified=None, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_vulnerability_if_not_exists(
    self,
    name,
    description,
    alias=None,
    id=None,
    stix_id_key=None,
    created=None,
    modified=None,
    update=False,
):
    return self.vulnerability.create(
        name=name,
        description=description,
        alias=alias,
        id=id,
        stix_id_key=stix_id_key,
        created=created,
        modified=modified,
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.delete_external_reference"><code class="name flex">
<span>def <span class="ident">delete_external_reference</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_external_reference(self, id):
    logging.info(&#34;Deleting + &#34; + id + &#34;...&#34;)
    query = &#34;&#34;&#34;
         mutation ExternalReferenceEdit($id: ID!) {
             externalReferenceEdit(id: $id) {
                 delete
             }
         }
     &#34;&#34;&#34;
    self.query(query, {&#34;id&#34;: id})</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.fetch_opencti_file"><code class="name flex">
<span>def <span class="ident">fetch_opencti_file</span></span>(<span>self, fetch_uri, binary=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_opencti_file(self, fetch_uri, binary=False):
    r = requests.get(fetch_uri, headers=self.request_headers)
    if binary:
        return r.content
    return r.text</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.health_check"><code class="name flex">
<span>def <span class="ident">health_check</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def health_check(self):
    try:
        test = self.threat_actor.list(first=1)
        if test is not None:
            return True
    except:
        return False
    return False</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, level, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, level, message):
    if level == &#34;debug&#34;:
        logging.debug(message)
    elif level == &#34;info&#34;:
        logging.info(message)
    elif level == &#34;warning&#34;:
        logging.warn(message)
    elif level == &#34;error&#34;:
        logging.error(message)</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.not_empty"><code class="name flex">
<span>def <span class="ident">not_empty</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def not_empty(self, value):
    if value is not None:
        if isinstance(value, str):
            if len(value) &gt; 0:
                return True
            else:
                return False
        if isinstance(value, list):
            is_not_empty = False
            for v in value:
                if len(v) &gt; 0:
                    is_not_empty = True
            return is_not_empty
        if isinstance(value, int):
            return True
        else:
            return False
    else:
        return False</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.process_multiple"><code class="name flex">
<span>def <span class="ident">process_multiple</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_multiple(self, data):
    result = []
    if data is None:
        return result
    for edge in (
        data[&#34;edges&#34;] if &#34;edges&#34; in data and data[&#34;edges&#34;] is not None else []
    ):
        row = edge[&#34;node&#34;]
        # Handle remote relation ID
        if (
            &#34;relation&#34; in edge
            and edge[&#34;relation&#34;] is not None
            and &#34;id&#34; in edge[&#34;relation&#34;]
        ):
            row[&#34;remote_relation_id&#34;] = edge[&#34;relation&#34;][&#34;id&#34;]
        result.append(self.process_multiple_fields(row))
    return result</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.process_multiple_fields"><code class="name flex">
<span>def <span class="ident">process_multiple_fields</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_multiple_fields(self, data):
    if data is None:
        return data
    if (
        &#34;createdByRef&#34; in data
        and data[&#34;createdByRef&#34;] is not None
        and &#34;node&#34; in data[&#34;createdByRef&#34;]
    ):
        row = data[&#34;createdByRef&#34;][&#34;node&#34;]
        # Handle remote relation ID
        if &#34;relation&#34; in data[&#34;createdByRef&#34;]:
            row[&#34;remote_relation_id&#34;] = data[&#34;createdByRef&#34;][&#34;relation&#34;][&#34;id&#34;]
        data[&#34;createdByRef&#34;] = row
    else:
        data[&#34;createdByRef&#34;] = None
    if &#34;markingDefinitions&#34; in data:
        data[&#34;markingDefinitions&#34;] = self.process_multiple(
            data[&#34;markingDefinitions&#34;]
        )
        data[&#34;markingDefinitionsIds&#34;] = self.process_multiple_ids(
            data[&#34;markingDefinitions&#34;]
        )
    if &#34;tags&#34; in data:
        data[&#34;tags&#34;] = self.process_multiple(data[&#34;tags&#34;])
        data[&#34;tagsIds&#34;] = self.process_multiple_ids(data[&#34;tags&#34;])
    if &#34;reports&#34; in data:
        data[&#34;reports&#34;] = self.process_multiple(data[&#34;reports&#34;])
        data[&#34;reportsIds&#34;] = self.process_multiple_ids(data[&#34;reports&#34;])
    if &#34;killChainPhases&#34; in data:
        data[&#34;killChainPhases&#34;] = self.process_multiple(data[&#34;killChainPhases&#34;])
        data[&#34;killChainPhasesIds&#34;] = self.process_multiple_ids(
            data[&#34;killChainPhases&#34;]
        )
    if &#34;externalReferences&#34; in data:
        data[&#34;externalReferences&#34;] = self.process_multiple(
            data[&#34;externalReferences&#34;]
        )
        data[&#34;externalReferencesIds&#34;] = self.process_multiple_ids(
            data[&#34;externalReferences&#34;]
        )
    if &#34;objectRefs&#34; in data:
        data[&#34;objectRefs&#34;] = self.process_multiple(data[&#34;objectRefs&#34;])
        data[&#34;objectRefsIds&#34;] = self.process_multiple_ids(data[&#34;objectRefs&#34;])
    if &#34;observableRefs&#34; in data:
        data[&#34;observableRefs&#34;] = self.process_multiple(data[&#34;observableRefs&#34;])
        data[&#34;observableRefsIds&#34;] = self.process_multiple_ids(
            data[&#34;observableRefs&#34;]
        )
    if &#34;relationRefs&#34; in data:
        data[&#34;relationRefs&#34;] = self.process_multiple(data[&#34;relationRefs&#34;])
        data[&#34;relationRefsIds&#34;] = self.process_multiple_ids(data[&#34;relationRefs&#34;])
    if &#34;stixRelations&#34; in data:
        data[&#34;stixRelations&#34;] = self.process_multiple(data[&#34;stixRelations&#34;])
        data[&#34;stixRelationsIds&#34;] = self.process_multiple_ids(data[&#34;stixRelations&#34;])
    if &#34;indicators&#34; in data:
        data[&#34;indicators&#34;] = self.process_multiple(data[&#34;indicators&#34;])
        data[&#34;indicatorsIds&#34;] = self.process_multiple_ids(data[&#34;indicators&#34;])
    if &#34;importFiles&#34; in data:
        data[&#34;importFiles&#34;] = self.process_multiple(data[&#34;importFiles&#34;])
        data[&#34;importFilesIds&#34;] = self.process_multiple_ids(data[&#34;importFiles&#34;])
    return data</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.process_multiple_ids"><code class="name flex">
<span>def <span class="ident">process_multiple_ids</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_multiple_ids(self, data):
    result = []
    if data is None:
        return result
    if isinstance(data, list):
        for d in data:
            if isinstance(d, dict) and &#34;id&#34; in d:
                result.append(d[&#34;id&#34;])
    return result</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, query, variables={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(self, query, variables={}):
    query_var = {}
    files_vars = []
    # Implementation of spec https://github.com/jaydenseric/graphql-multipart-request-spec
    # Support for single or multiple upload
    # Batching or mixed upload or not supported
    var_keys = variables.keys()
    for key in var_keys:
        val = variables[key]
        is_file = type(val) is File
        is_files = (
            isinstance(val, list)
            and len(val) &gt; 0
            and all(map(lambda x: isinstance(x, File), val))
        )
        if is_file or is_files:
            files_vars.append({&#34;key&#34;: key, &#34;file&#34;: val, &#34;multiple&#34;: is_files})
            query_var[key] = None if is_file else [None] * len(val)
        else:
            query_var[key] = val

    # If yes, transform variable (file to null) and create multipart query
    if len(files_vars) &gt; 0:
        multipart_data = {
            &#34;operations&#34;: json.dumps({&#34;query&#34;: query, &#34;variables&#34;: query_var})
        }
        # Build the multipart map
        map_index = 0
        file_vars = {}
        for file_var_item in files_vars:
            is_multiple_files = file_var_item[&#34;multiple&#34;]
            var_name = &#34;variables.&#34; + file_var_item[&#34;key&#34;]
            if is_multiple_files:
                # [(var_name + &#34;.&#34; + i)] if is_multiple_files else
                for _ in file_var_item[&#34;file&#34;]:
                    file_vars[str(map_index)] = [(var_name + &#34;.&#34; + str(map_index))]
                    map_index += 1
            else:
                file_vars[str(map_index)] = [var_name]
                map_index += 1
        multipart_data[&#34;map&#34;] = json.dumps(file_vars)
        # Add the files
        file_index = 0
        multipart_files = []
        for file_var_item in files_vars:
            files = file_var_item[&#34;file&#34;]
            is_multiple_files = file_var_item[&#34;multiple&#34;]
            if is_multiple_files:
                for file in files:
                    if isinstance(file.data, str):
                        file_multi = (
                            str(file_index),
                            (file.name, io.BytesIO(file.data.encode()), file.mime,),
                        )
                    else:
                        file_multi = (
                            str(file_index),
                            (file.name, file.data, file.mime),
                        )
                    multipart_files.append(file_multi)
                    file_index += 1
            else:
                if isinstance(files.data, str):
                    file_multi = (
                        str(file_index),
                        (files.name, io.BytesIO(files.data.encode()), files.mime),
                    )
                else:
                    file_multi = (
                        str(file_index),
                        (files.name, files.data, files.mime),
                    )
                multipart_files.append(file_multi)
                file_index += 1
        # Send the multipart request
        r = requests.post(
            self.api_url,
            data=multipart_data,
            files=multipart_files,
            headers=self.request_headers,
            verify=self.ssl_verify,
        )
    # If no
    else:
        r = requests.post(
            self.api_url,
            json={&#34;query&#34;: query, &#34;variables&#34;: variables},
            headers=self.request_headers,
            verify=self.ssl_verify,
        )
    # Build response
    if r.status_code == requests.codes.ok:
        result = r.json()
        if &#34;errors&#34; in result:
            logging.error(result[&#34;errors&#34;][0][&#34;message&#34;])
        else:
            return result
    else:
        logging.info(r.text)</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.resolve_role"><code class="name flex">
<span>def <span class="ident">resolve_role</span></span>(<span>self, relation_type, from_type, to_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_role(self, relation_type, from_type, to_type):
    if from_type == &#34;stix-relation&#34;:
        from_type = &#34;stix_relation&#34;
    if to_type == &#34;stix-relation&#34;:
        to_type = &#34;stix_relation&#34;
    if relation_type == &#34;related-to&#34;:
        return {&#34;from_role&#34;: &#34;relate_from&#34;, &#34;to_role&#34;: &#34;relate_to&#34;}

    relation_type = relation_type.lower()
    from_type = from_type.lower()
    from_type = (
        &#34;observable&#34;
        if (
            (
                ObservableTypes.has_value(from_type)
                and (
                    relation_type == &#34;localization&#34; or relation_type == &#34;gathering&#34;
                )
            )
            or from_type == &#34;stix-observable&#34;
        )
        else from_type
    )
    to_type = to_type.lower()
    mapping = {
        &#34;uses&#34;: {
            &#34;threat-actor&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
            },
            &#34;intrusion-set&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
            },
            &#34;campaign&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
            },
            &#34;incident&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
            },
            &#34;malware&#34;: {
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
            },
            &#34;tool&#34;: {&#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;}},
        },
        &#34;variant-of&#34;: {
            &#34;malware&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;original&#34;, &#34;to_role&#34;: &#34;variation&#34;},
            },
            &#34;tool&#34;: {&#34;tool&#34;: {&#34;from_role&#34;: &#34;original&#34;, &#34;to_role&#34;: &#34;variation&#34;},},
        },
        &#34;targets&#34;: {
            &#34;threat-actor&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
            &#34;intrusion-set&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
            &#34;campaign&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
            &#34;incident&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
            &#34;malware&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
            &#34;attack-pattern&#34;: {
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
        },
        &#34;attributed-to&#34;: {
            &#34;threat-actor&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
            },
            &#34;intrusion-set&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
            },
            &#34;campaign&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;intrusion-set&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
            },
            &#34;incident&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;intrusion-set&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;campaign&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
            },
            &#34;malware&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
            },
        },
        &#34;mitigates&#34;: {
            &#34;course-of-action&#34;: {
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;mitigation&#34;, &#34;to_role&#34;: &#34;problem&#34;}
            }
        },
        &#34;localization&#34;: {
            &#34;threat-actor&#34;: {
                &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
            },
            &#34;observable&#34;: {
                &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
            },
            &#34;stix_relation&#34;: {
                &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
            },
            &#34;region&#34;: {&#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}},
            &#34;country&#34;: {
                &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}
            },
            &#34;city&#34;: {&#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}},
            &#34;organization&#34;: {
                &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
            },
        },
        &#34;indicates&#34;: {
            &#34;indicator&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;from_role&#34;: &#34;indicator&#34;,
                    &#34;to_role&#34;: &#34;characterize&#34;,
                },
                &#34;intrusion-set&#34;: {
                    &#34;from_role&#34;: &#34;indicator&#34;,
                    &#34;to_role&#34;: &#34;characterize&#34;,
                },
                &#34;campaign&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                &#34;stix_relation&#34;: {
                    &#34;from_role&#34;: &#34;indicator&#34;,
                    &#34;to_role&#34;: &#34;characterize&#34;,
                },
            }
        },
        &#34;gathering&#34;: {
            &#34;threat-actor&#34;: {
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
            },
            &#34;sector&#34;: {
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
            },
            &#34;organization&#34;: {
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
            },
            &#34;user&#34;: {
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
            },
            &#34;observable&#34;: {
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
            },
        },
        &#34;drops&#34;: {
            &#34;malware&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
            },
            &#34;tool&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
            },
        },
        &#34;belongs&#34;: {
            &#34;ipv4-addr&#34;: {
                &#34;autonomous-system&#34;: {
                    &#34;from_role&#34;: &#34;belonging_to&#34;,
                    &#34;to_role&#34;: &#34;belonged_to&#34;,
                }
            },
            &#34;ipv6-addr&#34;: {
                &#34;autonomous-system&#34;: {
                    &#34;from_role&#34;: &#34;belonging_to&#34;,
                    &#34;to_role&#34;: &#34;belonged_to&#34;,
                }
            },
        },
        &#34;resolves&#34;: {
            &#34;ipv4-addr&#34;: {
                &#34;domain&#34;: {&#34;from_role&#34;: &#34;resolving&#34;, &#34;to_role&#34;: &#34;resolved&#34;,}
            },
            &#34;ipv6-addr&#34;: {
                &#34;domain&#34;: {&#34;from_role&#34;: &#34;resolving&#34;, &#34;to_role&#34;: &#34;resolved&#34;,}
            },
        },
        &#34;corresponds&#34;: {
            &#34;file-name&#34;: {
                &#34;file-md5&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha1&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha256&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
            },
            &#34;file-md5&#34;: {
                &#34;file-name&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha1&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha256&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
            },
            &#34;file-sha1&#34;: {
                &#34;file-name&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-md5&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha256&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
            },
            &#34;file-sha256&#34;: {
                &#34;file-name&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-md5&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha1&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
            },
        },
    }
    if (
        relation_type in mapping
        and from_type in mapping[relation_type]
        and to_type in mapping[relation_type][from_type]
    ):
        return mapping[relation_type][from_type][to_type]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.update_stix_observable_field"><code class="name flex">
<span>def <span class="ident">update_stix_observable_field</span></span>(<span>self, id, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_stix_observable_field(self, id, key, value):
    logging.info(&#34;Updating field &#34; + key + &#34; of &#34; + id + &#34;...&#34;)
    query = &#34;&#34;&#34;
        mutation StixObservableEdit($id: ID!, $input: EditInput!) {
            stixObservableEdit(id: $id) {
                fieldPatch(input: $input) {
                    id
                    observable_value
                    entity_type
                }
            }
        }
    &#34;&#34;&#34;
    self.query(query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}})</code></pre>
</details>
</dd>
<dt id="pycti.api.opencti_api_client.OpenCTIApiClient.upload_file"><code class="name flex">
<span>def <span class="ident">upload_file</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload_file(self, **kwargs):
    file_name = kwargs.get(&#34;file_name&#34;, None)
    data = kwargs.get(&#34;data&#34;, None)
    mime_type = kwargs.get(&#34;mime_type&#34;, &#34;text/plain&#34;)
    if file_name is not None:
        self.log(&#34;info&#34;, &#34;Uploading a file.&#34;)
        query = &#34;&#34;&#34;
            mutation UploadImport($file: Upload!) {
                uploadImport(file: $file) {
                    id
                    name
                }
            }
         &#34;&#34;&#34;
        if data is None:
            data = open(file_name, &#34;rb&#34;)
            mime_type = magic.from_file(file_name, mime=True)

        return self.query(query, {&#34;file&#34;: (File(file_name, data, mime_type))})
    else:
        self.log(
            &#34;error&#34;, &#34;[upload] Missing parameters: file_name or data&#34;,
        )
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycti.api" href="index.html">pycti.api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycti.api.opencti_api_client.File" href="#pycti.api.opencti_api_client.File">File</a></code></h4>
</li>
<li>
<h4><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient" href="#pycti.api.opencti_api_client.OpenCTIApiClient">OpenCTIApiClient</a></code></h4>
<ul class="">
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.create_vulnerability_if_not_exists" href="#pycti.api.opencti_api_client.OpenCTIApiClient.create_vulnerability_if_not_exists">create_vulnerability_if_not_exists</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.delete_external_reference" href="#pycti.api.opencti_api_client.OpenCTIApiClient.delete_external_reference">delete_external_reference</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.fetch_opencti_file" href="#pycti.api.opencti_api_client.OpenCTIApiClient.fetch_opencti_file">fetch_opencti_file</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.health_check" href="#pycti.api.opencti_api_client.OpenCTIApiClient.health_check">health_check</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.log" href="#pycti.api.opencti_api_client.OpenCTIApiClient.log">log</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.not_empty" href="#pycti.api.opencti_api_client.OpenCTIApiClient.not_empty">not_empty</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.process_multiple" href="#pycti.api.opencti_api_client.OpenCTIApiClient.process_multiple">process_multiple</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.process_multiple_fields" href="#pycti.api.opencti_api_client.OpenCTIApiClient.process_multiple_fields">process_multiple_fields</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.process_multiple_ids" href="#pycti.api.opencti_api_client.OpenCTIApiClient.process_multiple_ids">process_multiple_ids</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.query" href="#pycti.api.opencti_api_client.OpenCTIApiClient.query">query</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.resolve_role" href="#pycti.api.opencti_api_client.OpenCTIApiClient.resolve_role">resolve_role</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.update_stix_observable_field" href="#pycti.api.opencti_api_client.OpenCTIApiClient.update_stix_observable_field">update_stix_observable_field</a></code></li>
<li><code><a title="pycti.api.opencti_api_client.OpenCTIApiClient.upload_file" href="#pycti.api.opencti_api_client.OpenCTIApiClient.upload_file">upload_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>